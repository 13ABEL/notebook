Nothing is a compile time abstraction
explicitly indicates failure - function never completes successfully

Nothing is a subtype of every class

why `Nothing` over `Unit`?
> `Unit` is a subtype of `Any`. Makes it difficult to work with
Ex. suppose we have a function `getString() : String?`. In our use case -> we should throw an exception if calling `getString()` returns `null`.

This this is what it would look like without `Nothing`:	
	val username : String? = args.getString("username")
	if (username == null) {
		throw CustomE("User doesn't exist")
	} else {
		// perform operation using username
	}
	... rest of code

This is alot more concise (imo the throw is just as explicit so no advantage there)
	fun fail(message : String) : Nothing {
		throw CustomE(message) 
	}

	val username = args.getString("username") ?: fail("User doesn't exist")
	// perform rest of operation using username
	... rest of code

Using `Nothing`, we can avoid the additional null check after calling `getString()`. This preserves the verbosity of failure without polluting our code with a bunch of null checks
	
